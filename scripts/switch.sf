#!/usr/bin/ruby

# Because everything is an object, we can say:

var i = 3;
var j = 4;
var condition = ( given(1+3) );

condition
    when (3) do {
        condition.value == 3 || ("Error(1 - 3)\n".die);
    }
    when (i) do {
        condition.value == i || ("Error(1 - i)\n".die);
    }
    when (j) do {
        condition.value == j || ("Error(1 - j)\n".die);
    }
    default {
        "Can't find what I was looking for...".die;
    }
end;

var value = "sidef";

given (value)
    when ("x") do {
        "Not the right place! (1)".die;
    }
    when ("sidef") do {
        "Right place! (1)".say;
    }
    when ("y") do {
        "Not the right place! (2)".die;
    }
    default {
        "Not the right place! (3)".die;
    }
end;


given (value)
    when (3) do {
        "Not the right place! (1)".die;
    }
    when ([5,2]) do {
        "Not the right place! (2)".die;
    }
    when ("sidef") do {
        "Right place! (2)".say;
    }
    default {
        "Not the right place! (3)".die;
    }
end;


{value}.given
    when ("x") do {
        "Not the right place! (1)".die;
    }
    when ("y") do {
        "Not the right place! (2)".die;
    }
    when ("z") do {
        "Not the right place! (3)".die;
    }
    default {
        "Right place! (3)".say;
    }
end;


{value}.given
    when ("x") do {
        "Not the right place! (1)".die;
    }
    when ("y") do {
        "Not the right place! (2)".die;
    }
    when ("sidef") do {
        "Right place! (4)".say;
    }
    default {
        "Not the right place! (3)".die;
    }
end;


given([8,9,10])
    when ("x") do {
        "Not the right place! (1)".die;
    }
    exact([8,10,9]) do {
        "Not the right place! (2)".die;
    }
    exact([8,9,10]) do {
        "Right place! (5)".say;
    }
    when ([42]) do {
        "Not the right place! (3)".die;
    }
end;


given(0)
    when (1) do {
        "Not the right place! (1)".die;
    }
    exact ('0') do {
        "Not the right place! (2)".die;
    }
    when (0) do {
        "Right place! (6)".say;
        continue;
    }
    when (2) do {
        "Not the right place! (3)".die;
    }
    when (1-1) do {
        "Right place! (6 - continued)".say;
    }
    default {
        "Not the right place! (4)".die;
    }
end;


switch(var val = 0)
    case (val == 1) do {
        "Not the right place! (1)".die;
    }
    case (val == 0) do {
        "Right place! (case)".say;
        continue;
    }
    case (false) do {
        "Not the right place! (2)".die;
    }
    when (true) do {
        "Not the right place! (3)".die;
    }
    case (0) do {
        "Right place! (case-continued)".say;
    }
    default {
        "Case error!".die;
    }
end;


given (3)
    when (1) do {
        "Error!".die;
    }
    when (2) do {
        "Error!".die;
    }
    when (3) do {
        "Right place! (given)".say;
    }
    when (3) do {
        "Error!".die;
    }
    default {
        "Error!".die;
    }
end;

#
## 'given' stripped down without a required 'do' keyword
#
given(var n = 1)
    case (n < 0) {
        "it's negative".die;
    }
    when (0) {
        "it's zero".die;
    }
    when (1) {
        say "it's a one";
    }
    default {
        "Greater than one...".die;
    };

#
## Test switch with recursion and return value
#

func quickselect(a, k) {
    var pivot = a.pick;
    var left  = a.grep{|i| i < pivot};
    var right = a.grep{|i| i > pivot};

    switch(var l = left.len)
        when(k)     { pivot }
        case(k < l) { __FUNC__(left, k) }
        default     { __FUNC__(right, k - l - 1) };
}

var v = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4];
v.range.map{|i| quickselect(v, i)} == v.sort || die "Error!";
