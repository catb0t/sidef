#!/usr/bin/ruby

#
## Extend the language with a block and a class
#
class Catch(do, value) {
    method my_catch(block) {
        do ? block.run : value;
    }
}

func my_try(block) {
    var bool = block.run;
    if (bool) {
        Catch.new(do: false, value: bool);
    }
    else {
        Catch.new(do: true, value: bool);
    }
}

var x = 0;

my_try {
    say "Trying...";
    1 == 2;
}
my_catch {
    say "Catched!";
    x = 42;
};

assert_eq(x, 42);


#
## Extend the language using only classes
#

class my_if {

    def did = false;

    method new(cond, callback) {
        !did && cond && (callback(); did = true);
        self;
    };

    # Alias "my_elsif" to "if"
    __CLASS__.def_method(:my_elsif, new);

    method my_else(callback) {
        !did && callback();
        self;
    }
}

#
## Test elsif (alias for 'if')
#
my_if (false) {
    die "my_if error";
}
my_elsif (true) {
    say "my_elsif correct!";
}
my_else {
    die "my_else error";
};

#
## Test my_else
#
my_if (false) {
    die "my_if error";
}
my_elsif (false) {
    die "my_elsif error";
}
my_else {
    say "my_else correct!";
};


#
## Method with block call
#

class Test {
    method hello(callback) {
        callback();
    }
}

var obj = Test();

var y = 0;
obj.hello {
    say "Test passed!";
    y = 42;
};
assert_eq(y, 42);
