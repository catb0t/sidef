#!/usr/bin/ruby

#
## Hash declaration from pairs:
#

var new_h = Hash.new(
    a: 1,
    b: 2,
    c: 3,
);

say new_h[:c];


#
## Named parameters for callable objects
#

func f(x, n) {
    x**2 + 3*n + 5;
}

say f(n:4, x:2);  # the order doesn't matter


#
## Hash-like access to class variables
#

class Person(name, age) {
    method sleep {
        say "I'm taking a nap now...";
    }
}

var pers = Person(name: "John Smith", age: 35);

say pers[:name];    # person's name
say pers[:age];     # person's age

# which is equivalent with:
say pers.name;
say pers.age;

# but internally different from (which is a method):
pers.sleep;


#
## Hash default value
#

var hash = Hash.new -> default(0);

"abracadabra".each { |c|
    hash[c]++;
}

hash.sort_by{|_,v| v}.reverse.each { |k,v|
    say "#{k}: #{v}";
}


#
## Regexp match variables
#

"This is Sidef" =~ /(\S+)$/;
say "We <3 #{$1}";


#
## Structures
#

struct Company {
    name  = "Google",
    field = "Technology",
};

Company.since(1991);
Company.webbrowser = "Google Chrome";

say "© #{Company.since}-#{Time.new.local.year + 1900}, #{Company.name}";
say Company.webbrowser;


#
## ARGF filehandle
#

if (ARGV.len) {
    print ARGF.readline;
}


#
## Fancy delimiters in more places
#

var «x, y, z» = (5, 8, 13);
say x+y*z;

func f „x” {
    x**2 + 4;
}

say f(2);


#
## The 'eval' keyword
#

say eval <<'CODE';
    func factorial«n» {
        n > 1 ? (n * __FUNC__(n-1)) : 1;
    }

    factorial(5);
CODE


#
## The 'Parser' keyword
#

{}.new(Parser.parse_script(:code => 'var p = "Low-level parsing!"; say p')).run;


#
## Support for modules and new parser tokens
#

module New::Features {
    class Demo {
        method Fib(n=6) {
            n > 1 ? (__METHOD__(self, n-2) + __METHOD__(self, n-1)) : n;
        }

        __CLASS__ += ('Metaprogramming', {|self| "Welcome to metaprogramming!"});

        method Info {
            :(
                :class  => __CLASS_NAME__,
                :method => __METHOD_NAME__,
                :time   => __TIME__,
                :date   => __DATE__,
                :script => __MAIN__,
                :module => __NAMESPACE__,
            );
        }
    }
}

var obj = New::Features::Demo();
say obj.Fib(4);

var info = obj.Info;
info.keys.sort.map {|k| "%6s: %s".sprintf(k, info[k])}.join("\n").say;

var name = 'Meta';
say obj.(name + 'programming');


#
## Smart match operator (~~)
#

say ([1,2,3] ~~ 3);         # true (array contains 3)
say ("sidef" ~~ "id");      # true (string contains "id")
say (:z ~~ :(z: 26));       # true ('z' exists in hash)
say (:(a: 1) ~~ :a);        # true (hash has key 'a')


#
## Function return type
#

func typed(num) -> Bool {
    return (num == 4);
}

typed(4);
