#!/usr/bin/ruby

define e     = Number.e;
define PI    = Number.pi
define TAU   = Number.tau;
define NAMES = %w(Unknown Ramanujan Trizen Stirling Stirling+Laplace Ramanujan2 Batir Batir2 Batir2WA);

# Unknown
# sqrt(2*pi*e) * e^(-((3 - sqrt(3)) / 6)) * (((3 - sqrt(3)) / 6 + n) / e)^(n + 1/2)
func f1(n) {
    define w = ((3 - 3.sqrt) / 6);
    define d = (TAU * e -> sqrt * Math.exp(-w));
    d * (Math.pow((n+w) / e, n + 1/2));
}

# S. Ramanujan's formula
# exp(n * log(n) - n + (log(n * (1 + (4*n * (1 + 2*n)))) / 6) + log(pi)/2)
func f2(n) {
    define d = (PI.log / 2);
    Math.exp(n * n.log - n + (n * (1 + (4*n * (1 + 2*n))) -> log / 6) + d);
}

# Trizen's formula (not recommended)
# For small n
#   (n+1)^(n+1) / e^(n+1) * (e / sqrt(n+1)) / e^(1/((12 + 1/(n+1)^(1/(e + (1 / (n + 1 - (log((n+1)*2) / log(n+2))))))) * e^(1/(n+1))))
# Asymptotic
#   sqrt(2*pi) / e^(11/12) * (n+1)^(n+1) / e^(n+1) * (e / sqrt(n+1)) / e^(1/((12 + 1/(n+1)^(1/e)) * e^(1/(n+1))))
#   sqrt(2*pi) * (n+1)^(n+1/2) * e^(-(e^(-1/(n+1)) * (n+1)^(1/e))/(12 * (n+1)^(1/e) + 1) - n - 11/12)
func f3(n) {
    if (n < 100) {
        # For small n
        n**n / n.exp * (e / n.sqrt) / e.root((12 + 1/n.root(e + (1 / (n - ((n*2).log(n+1)))))) * e.root(n));
    }
    else {
        # Asymptotic
        define d = (TAU.sqrt / exp(11/12))
        d * n**n / n.exp * (e / n.sqrt) / e.root((12 + 1/n.root(e)) * e.root(n));
    }
}

# Stirling's formula
# sqrt(2*pi*n) * (n/e)^n
func f4(n) {
    TAU * n -> sqrt * Math.pow(n / e, n);
}

# Stirling's formula + Laplace's method (1)
# sqrt(2*pi*n) * (n/e)^n * (1 + 1/(12*n))
func f5(n) {
    TAU * n -> sqrt * Math.pow(n / e, n) * (1 + 1/(12*n));
}

# S. Ramanujan (2)
# sqrt(pi) * n^n * e^(-n) * ((8 * n^3) + (4 * n^2) + n + 1/30)^(1/6)
func f6(n) {
    define w = (PI.sqrt);
    w * Math.pow(n, n) * Math.exp(-n) * Math.pow(((8 * n**3) + (4 * n**2) + n + 1/30), 1/6);
}

# N. Batir
# sqrt(2*pi) * n^n * e^(-n) * sqrt(n + 1/2) * e^(-(1 / (6 * (n + 3/8))))
func f7(n) {
    define w = (TAU.sqrt);
    w * Math.pow(n, n) * Math.exp(-n) * (n + 1/2 -> sqrt) * Math.exp(-(1 / (6 * (n + 3/8))));
}

# N. Batir(2)
# sqrt(2*pi) * n^n * e^(-n) * sqrt(n + 1/6 + 1/(72*n) - 31/(6480 * n^2) - 139/(155520 * n^3) + 9871/(6531840 * n^4))
func f8(n) {
    define w = (TAU.sqrt);
    w * Math.pow(n, n) * e**(-n) * (n + 1/6 + 1/(72*n) - 31/(6480 * n**2) - 139/(155520 * n**3) + 9871/(6531840 * n**4) -> sqrt);
}

# N. Batir(2) derivation by WolframAlpha
# 1/216 * sqrt(pi/70) * exp(-n) * n^(n-2) * sqrt(42*n*(24*n*(90*n*(12*n*(6*n + 1) + 1) - 31) - 139) + 9871)
func f9(n) {
    1/216 * Math.sqrt(PI/70) * e**(-n) * n**(n-2) * Math.sqrt(42*n*(24*n*(90*n*(12*n*(6*n + 1) + 1) - 31) - 139) + 9871);
}

#
## TESTS
#

var report = Hash()
for x in (1..10) {

    var xfact = x!;
    var arr = [f1(x), f2(x), f3(x+1), f4(x), f5(x), f6(x), f7(x), f8(x), f9(x)];

    for name in NAMES {
        report{name} := [] += arr.shift;
    }

    "\n%-22d%s\n".printf(x, xfact);
    for name in NAMES {
        "%20s: %s\n".printf(name, report{name}[-1]);
    }

    report{:REAL} \\= [];
    report{:REAL}.append(xfact);
}

func A(a) { a.sum / a.len }
func G(a) { a.prod.root(a.len) }
func H(a) { a.len / a.map{1/_}.sum }

var r1 = Hash()
var r2 = Hash()
var r3 = Hash()

NAMES.each {|name|
    var arr = report{name}.range.map {|i| report{:REAL}[i] - report{name}[i] -> abs}
    r1{name} = A(arr);
    r2{name} = G(arr);
    r3{name} = H(arr);
}

func print_report(h) {
    for k,v in (h.sort_by {|_,v| v }) {
        "%20s: %s\n".printf(k, v);
    }
}

say ("\n", '-'*80);

say "\n=>> A <<=";
print_report(r1);

say "\n=>> G <<=";
print_report(r2)

say "\n=>> H <<=";
print_report(r3);

say ("\n", '-'*80);
