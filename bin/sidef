#!/usr/bin/perl

# This script will require Lexer.pm
# and execute the returned data struct.

use 5.014;
use strict;
use warnings;

use lib '../lib';    # devel only
use autouse 'Getopt::Std' => qw(getopts($;$));    # arguments support

my %args;
if (qr/^-/ ~~ \@ARGV) {
    getopts('E:', \%args);
}

# It can be executed as:
#   perl sidef -E '"test"->say'

my $code = exists $args{E} ? $args{E} : <<'CODE';

###################################
# Error testing
###################################
#test->3;     # Invalid object type!
#3->5;        # Invalid method name!
###################################


###################################
# Code testing
###################################

(42 / ( 3/(1.0) ) )->to_s->say;   # prints 14

((((((60+(40)))))))->to_s->say;   # prints 100

((42-(4.3*(3)))/(6))->to_s->say;  # prints 4.85

-81->abs->sqrt->to_s->say;        # prints 9

24/(18*(3/(1)))->to_s->say;       # prints 0.444444444444444

"StRinG"->lc->uc->say;            # prints STRING

44.2->int->log10->to_s->say;      # prints 1.64345267648619

###################################

CODE

require Sidef::Lexer;
my $lexer = Sidef::Lexer->new();
my ($struct, $pos) = $lexer->parse_script(code => $code);

#use Data::Dump qw(pp);
#pp $struct;

=cut
    {
      call => [{ name => "sqrt" }, { name => "to_s" }, { name => "print" }],
      self => bless(do{\(my $o = 81)}, "Sidef::Types::Number::Integer"),
    },
=cut

sub execute_expr {
    my (%opt) = @_;

    my $expr = $opt{'expr'};

    if (exists $expr->{self}) {

        my $self = $expr->{self};

        if (ref $self eq 'HASH') {
            ($self) = execute(struct => $self);
        }

        if (exists $expr->{call}) {
            foreach my $call (@{$expr->{call}}) {

                my @arguments;
                my $method = $call->{name};

                if (exists $call->{arg}) {

                    foreach my $arg (@{$call->{arg}}) {

                        if (exists $arg->{main}) {
                            foreach my $arg_expr (@{$arg->{main}}) {
                                my $eval_arg = execute_expr(expr => $arg_expr);
                                push @arguments, $eval_arg;
                            }
                        }

                    }

                    $self = $self->$method(@arguments);
                }
                else {

                    $self = $self->$method;
                }
            }
        }

        return $self;
    }
    else {
        die "Struct error!\n";
    }
}

sub execute {
    my (%opt) = @_;

    my $struct = $opt{'struct'};

    my @results;
    foreach my $key (keys %{$struct}) {
        foreach my $expr (@{$struct->{$key}}) {
            push @results, execute_expr(expr => $expr);
        }
    }

    return @results;
}

execute(struct => $struct);
