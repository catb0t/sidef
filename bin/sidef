#!/usr/bin/perl

use 5.014;
use strict;
use warnings;

no if $] >= 5.018, warnings => "experimental::smartmatch";

binmode(STDOUT, ':utf8');
binmode(STDERR, ':utf8');
binmode(STDIN,  ':utf8');

use lib '../lib';    # devel only
use autouse 'Getopt::Std' => qw(getopts($;$));    # arguments support

my %args;
if (@ARGV and chr ord $ARGV[0] eq '-') {
    getopts('E:d:Dho:', \%args);
}

if ($args{h}) {

    my %switches = (
                    '-d dumped_file' => 'execute a dumped file',
                    '-D'             => 'dump the data structure of a program',
                    '-o output_file' => 'dump the data structure into a file (with -D)',
                    '-E program'     => 'one line of program',
                   );

    print <<"USAGE";

Usage: sidef [switches] [--] [programfile] [arguments]

USAGE

    require List::Util;
    my $max_width = List::Util::max(map { length } keys %switches);
    $max_width += 4;

    foreach my $key (sort { lc($a) cmp lc($b) } keys %switches) {
        printf "  %-${max_width}s%s\n", $key, $switches{$key};
    }

    print <<"END";

Run 'man sidef' for more help with Sidef.

END

    exit 0;
}

my $struct;

if (defined $args{d}) {
    require Sidef::Init;
    $struct = do($args{d})
      || die "Can't load the data structure from file '$args{d}': $!\n";
}
else {
    require Sidef::Parser;

    my $script_name = '-';

    my $code =
      exists $args{E}
      ? do { $script_name = '-E'; utf8::decode($args{E}); $args{E} }
      : (defined($ARGV[0]) && -f $ARGV[0]) ? do {

        my $file = shift;
        $script_name = $file;

        open my $fh, '<:utf8', $file
          or die qq{Can't open sidef script "$file": $!\n};

        local $/;
        <$fh>;

      }
      : join(' ', <>);

    my $arguments = @ARGV ? (q{'} . join(q{','}, (map { s/(['\\])/\\$1/gr } @ARGV)) . q{'}) : '';
    utf8::decode($arguments);

    #
    ## Predeclared variables and constants
    #

    my $header = <<"EOH";

var   ARGV       = [$arguments];
const OSNAME     = '$^O';
const EXEC       = (File.new("\Q$0\E"));
const SCRIPT     = (File.new("\Q$script_name\E"));

__RESET_LINE_COUNTER__;
EOH

    my $parser = Sidef::Parser->new(script_name => $script_name);
    $struct = $parser->parse_script(code => $header . $code);
}

if ($args{D}) {
    eval 'use Data::Dump';

    if ($@) {
        die "Data::Dump module is not installed!\n";
    }
    else {
        my $out_fh = \*STDOUT;

        if (defined $args{o}) {
            open $out_fh, '>:utf8', $args{o}
              or die "Can't open file '$args{o}' for write: $!\n";
        }

        print {$out_fh} Data::Dump::pp($struct);
    }
}
else {
    require Sidef::Exec;
    my $exec = Sidef::Exec->new();
    $exec->execute(struct => $struct);
}
