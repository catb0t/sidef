#!/usr/bin/perl

# This script will require Lexer.pm
# and execute the returned data struct.

use 5.014;
use strict;
use warnings;

use lib '../lib';    # devel only
use autouse 'Getopt::Std' => qw(getopts($;$));    # arguments support

my %args;
if (qr/^-/ ~~ \@ARGV) {
    getopts('E:', \%args);
}

# It can be executed as:
#   perl sidef -E '"test"->say'

my $code = exists $args{E} ? $args{E} : <<'CODE';

###################################
# Error testing
###################################
# test->3;     # Invalid object type!
# 3->5;        # Invalid method name!
# var->say;    # Attempt to use an uninitialized variable: <var>
###################################


###################################
# Code testing
###################################

hello = ("Hello, World!");        # assign a string value to variable 'hello'
hello->say;                       # prints "Hello, World!" from var 'hello'

hello = ("Goodbye, World!");      # assign another string to variable 'hello'
hello->say;                       # prints the last assigned string.

diff = (43-(23));                 # assign value to diff
diff->to_s->say;                  # print the values assigned to diff (20)

(42 / ( 3/(1.0) ) )->to_s->say;   # prints 14

((((((60+(40)))))))->to_s->say;   # prints 100

((42-(4.3*(3)))/(6))->to_s->say;  # prints 4.85

-81->abs->sqrt->to_s->say;        # prints 9

24/(18*(3/(1)))->to_s->say;       # prints 0.444444444444444

"StRinG"->lc->uc->say;            # prints STRING

44.2->int->log10->to_s->say;      # prints 1.64345267648619

###################################

CODE

require Sidef::Lexer;
my $lexer = Sidef::Lexer->new();
my ($struct, $pos) = $lexer->parse_script(code => $code);

#use Data::Dump qw(pp);
#pp $struct;

=cut
    {
      call => [{ name => "sqrt" }, { name => "to_s" }, { name => "print" }],
      self => bless(do{\(my $o = 81)}, "Sidef::Types::Number::Integer"),
    },
=cut

my %variables;

sub execute_expr {
    my (%opt) = @_;

    my $expr = $opt{'expr'};

    if (exists $expr->{self}) {

        my $self = $expr->{self};
        if (ref $self eq 'HASH') {
            ($self) = execute(struct => $self);
        }

        if (exists $expr->{call}) {
            foreach my $call (@{$expr->{call}}) {

                my @arguments;
                my $method = $call->{name};

                if (exists $call->{arg}) {

                    foreach my $arg (@{$call->{arg}}) {

                        if (ref $arg eq 'HASH') {
                            push @arguments, execute(struct => $arg);
                        }
                        else {
                            push @arguments, $arg;
                        }
                    }

                    $self = $self->$method(@arguments);
                }
                else {

                    if (ref $self eq 'Sidef::Variable::Variable') {
                        $self = $self->get_value;
                    }

                    $self = $self->$method;
                }
            }
        }

        return $self;
    }
    else {
        die "Struct error!\n";
    }
}

sub execute {
    my (%opt) = @_;

    my $struct = $opt{'struct'};

    my @results;
    foreach my $key (keys %{$struct}) {
        foreach my $expr (@{$struct->{$key}}) {
            push @results, execute_expr(expr => $expr);
        }
    }

    return @results;
}

execute(struct => $struct);
