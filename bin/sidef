#!/usr/bin/perl

use 5.014;
use strict;
use warnings;

BEGIN { unshift(@INC, '../lib') }

binmode(STDOUT, ':encoding(UTF-8)');
binmode(STDERR, ':encoding(UTF-8)') if $^P == 0;
binmode(STDIN,  ':encoding(UTF-8)');

require Sidef;
require Sidef::Parser;

my $name    = 'Sidef';
my $version = $Sidef::VERSION;

my %args;
if (@ARGV and chr ord $ARGV[0] eq '-') {
    require Getopt::Std;
    Getopt::Std::getopts('E:d:Dho:ivHN:Ww', \%args);
}

my %keywords = (
                if   => 'Sidef::Types::Bool::If',
                '\\' => 'Sidef::Variable::Ref',
                '*'  => 'Sidef::Variable::Ref',
               );

sub help_interactive {
    require Term::ReadLine;
    my $term = Term::ReadLine->new("$name $version -- help interactive mode");

    print <<"HELP";
Welcome to $name $version!  This is the interactive help utility.

Enter the name of any object, keyword, or topic to get help on writing
$name programs and using $name modules.  To quit this help utility, just
type "quit".

To get a list of available objects, or keywords, type "objects" or "keywords".

HELP

    {
        my $line = $term->readline('help> ') // do { print "\n"; return };

        my $parser = Sidef::Parser->new(script_name => '-H');
        my $struct = eval { $parser->parse_script(code => $line) };

        if ($@) {
            warn $@;
            redo;
        }

        my @refs = exists($keywords{$line}) ? $keywords{$line} : (map { ref($_) } execute_struct($struct));

        foreach my $ref (@refs) {
            $ref eq '' && do { warn "Not an object!\n"; next };
            system "man", $ref;
        }

        redo;
    }

}

if ($args{h}) {

    my %switches = (
                    '-i'             => 'interactive mode',
                    '-d dumped_file' => 'execute a dumped file',
                    '-D'             => 'dump the data structure of a program',
                    '-o output_file' => 'dump the data structure into a file (with -D)',
                    '-E program'     => 'one line of program',
                    '-H'             => 'interactive help',
                    '-N type'        => ["use a specific implementation for numbers", "valid types: fast, big, int, rat"],
                    '-v'             => 'print version',
                    '-w'             => 'enable warnings with stack backtrace',
                    '-W'             => 'make warnings fatal (with stack backtrace)',
                   );

    print <<"USAGE";

Usage: sidef [switches] [--] [programfile] [arguments]

USAGE

    require List::Util;
    my $max_width = List::Util::max(map { length } keys %switches);
    $max_width += 4;

    foreach my $key (sort { lc($a) cmp lc($b) or $b cmp $a } keys %switches) {
        if (ref $switches{$key} eq 'ARRAY') {
            printf "  %-${max_width}s%s\n", $key, $switches{$key}[0];
            foreach my $i (1 .. $#{$switches{$key}}) {
                printf "  %-${max_width}s%s\n", '', $switches{$key}[$i];
            }
        }
        else {
            printf "  %-${max_width}s%s\n", $key, $switches{$key};
        }
    }

    print <<"END";

Run '$0 -H' for more help with $name.

END

    exit 0;
}

if ($args{w}) {
    $SIG{__WARN__} = sub {
        require Carp;
        Carp::cluck(@_);
    };
}
elsif ($args{W}) {
    $SIG{__WARN__} = sub {
        require Carp;
        Carp::confess(@_);
    };
}

if (defined(my $type = $args{N})) {
    if ($type eq 'fast' or $type eq 'perl') {
        require Sidef::Types::Number::NumberFast;
    }
    elsif ($type eq 'rat') {
        require Sidef::Types::Number::NumberRat;
    }
    elsif ($type eq 'int') {
        require Sidef::Types::Number::NumberInt;
    }
    elsif ($type eq 'big' or $type eq 'float') {
        ## default
    }
    else {
        warn "Invalid type '${type}' for number implementation";
    }
}

if (defined $args{d}) {
    require Sidef::Init;
    my $struct = do($args{d})
      || die "Can't load the data structure from file '$args{d}': $!\n";
    execute_struct($struct);
}
elsif (defined $args{H}) {
    help_interactive();
}
elsif (defined $args{v}) {
    print "$name $version\n";
    exit;
}
else {
    if (defined $args{i}) {
        require Term::ReadLine;
        my $term = Term::ReadLine->new("$name $version -- interactive mode");

        print qq{$name $version on $^O\n};
        print qq{Type "help", "copyright", "credits" or "license" for more information.\n};

        {
            my $line = $term->readline('>>> ') // do { print "\n"; exit };

            if ($line eq 'help') {
                help_interactive();
            }

            my $parser = Sidef::Parser->new(script_name => '-i');
            my $struct = eval { $parser->parse_script(code => $line) };

            if ($@) {
                warn $@;
                redo;
            }

            say for execute_struct($struct);
            redo;
        }

    }
    else {
        my $script_name = '-';

        my $code =
          exists $args{E}
          ? do { $script_name = '-E'; require Encode; Encode::decode_utf8($args{E}) }
          : (defined($ARGV[0]) && -f $ARGV[0]) ? do {

            my $file = shift;
            $script_name = $file;

            open my $fh, '<:encoding(UTF-8)', $file
              or die qq{Can't open sidef script "$file": $!\n};

            local $/;
            <$fh>;
          }
          : do { local $/; <> };

        $code // exit 2;
        my $parser = Sidef::Parser->new(script_name => $script_name);
        my $struct = $parser->parse_script(code => $code);

        if ($args{D}) {
            eval 'use Data::Dump';

            if ($@) {
                die "Data::Dump module is not installed!\n";
            }
            else {
                my $out_fh = \*STDOUT;

                if (defined $args{o}) {
                    open $out_fh, '>:encoding(UTF-8)', $args{o}
                      or die "Can't open file '$args{o}' for write: $!\n";
                }

                print {$out_fh} Data::Dump::pp($struct);
            }
        }
        else {
            execute_struct($struct);
        }
    }
}

sub execute_struct {
    my ($struct) = @_;

    require Sidef::Exec;
    my $exec = Sidef::Exec->new();
    $exec->execute($struct);
}
