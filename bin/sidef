#!/usr/bin/perl

# This script will require Lexer.pm
# and execute the returned data struct.

use 5.014;
use strict;
use warnings;

use lib '../lib';    # devel only
use autouse 'Getopt::Std' => qw(getopts($;$));    # arguments support

my %args;
if (qr/^-/ ~~ \@ARGV) {
    getopts('E:', \%args);
}

# It can be executed as:
#   perl sidef -E '"test"->say'

my $code = exists $args{E} ? $args{E} : <<'CODE';

###################################
# Error testing
###################################
# +->say;      # Invalid object type!
# 3->5;        # Invalid method name!
# var->say;    # Attempt to use an uninitialized variable: <var>
###################################


###################################
# Code testing
###################################

###################
# SUPPORT FOR FILES
###################

var file = ~sidef~;

var size_kb = (file->size / 1024);

"Size of sidef in bytes: "->print;
size_kb * 1024 -> to_s -> say;

"size of file 'sidef': $size_kb KB\n"->print;

var fh = (file->open_r);
"\n** Reading one line from 'sidef':" -> say;
fh->readline->print;

file = ("sidef"->stat_file);

"\nFile name is: "->print;
file->name->say;

"Full path is: "->print;
var abs_path = (file->abs_name)->to_s->say;

"Dir name is:  "->print;
abs_path->dirname->to_s->say;

###############################################
##### NEW WAY TO INITIALIZE THE VARIABLES #####
###############################################
#
# optional parentheses for arguments
#
###############################################

var x = "RaNdOm StRiNg"->lc;   # WRONG!!!
var y = ("RaNdOm StRiNg"->lc); # RIGHT!!!
var z = "\LRaNdOm StRiNg";     # Also, right.

"\nescaped variable: \$var\n"->say;

#
## Single-quoted string to double-quoted string
#

var single = 'this is a test -- $y -- \n';
single->say;
(single->to_sd)->say;

# -----------------------------------------------

x->say;     # prints 'RaNdOm StRiNg'
y->say;     # prints 'random string'

var name = "Ioana";       # initialize variable "name"

"Hello, $name! How are you? :)\n"->print;
name->uc->say;

6+4/2->to_s->say;       # WRONG!!! Prints 5
6+(4/2)->to_s->say;     # RIGHT!!! Prints 8

12/3*4->to_s->say;      # Prints 16

###############################################
################# OTHER STUFF #################
###############################################

var num = 42;
"Next power of two after number $num is: "->print;
num->next_power_of_two->to_s->say;

var init = "^_^ Sidef ^_^"->say;  # assings to variable 'init', and prints it
init->uc->say;                    # upper cases the variable 'init', and prints it again

"\n\uvariable interpolation ==> \L$init\\\\\E <== is Working\n"->say;

var hello = "Hello, World!";      # assign a string value to variable 'hello'
hello->say;                       # prints "Hello, World!" from var 'hello'

hello = ("Goodbye, World!\n");    # assign another string to variable 'hello'
hello->print;                     # prints the last assigned string.

var diff = (43-23);               # assign value to 'diff'
diff->to_s->say;                  # print the value stored into 'diff' (20)

(42 / ( 3/(1.0) ) )->to_s->say;   # prints 14

24 -> / (6)->to_s->say;           # prints 4 ( "/" is a method! )

((((((60+(40)))))))->to_s->say;   # prints 100

((42-(4.3*(3)))/(6))->to_s->say;  # prints 4.85

-81->abs->sqrt->to_s->say;        # prints 9

10/(3)->to_s->say;                # prints 3.3333333333333

24/(18*(3/(1)))->to_s->say;       # prints 0.444444444444444

"StRinG"->lc->uc->say;            # prints STRING

44.2->int->log10->to_s->say;      # prints 1.64345267648619

###################################

CODE

require Sidef::Lexer;
my $lexer = Sidef::Lexer->new();
my ($struct, $pos) = $lexer->parse_script(code => $code);

#use Data::Dump qw(pp);
#pp $struct;

=cut
    {
      call => [{ name => "sqrt" }, { name => "to_s" }, { name => "print" }],
      self => bless(do{\(my $o = 81)}, "Sidef::Types::Number::Integer"),
    },
=cut

my %variables;

sub interpolate {
    my (%opt) = @_;

    my $self = $opt{self};

    ${$self} =~ s{(?<!\\)(?:\\\\)*+\K\$([a-zA-Z_]\w*)\b}{
                exists $variables{$opt{class}}{$1}
                    ? $variables{$opt{class}}{$1}
                    : do{
                        warn "Use of uninitialized variable <$1> in double quoted string!\n";
                        q{};
                    };
        }eg;

    $self->apply_escapes;
}

sub execute_expr {
    my (%opt) = @_;

    my $expr = $opt{'expr'};

    if (exists $expr->{self}) {

        my $self = $expr->{self};
        if (ref $self eq 'HASH') {
            ($self) = execute(struct => $self);
        }

        if (ref $self eq 'Sidef::Types::String::Double') {
            interpolate(self => $self, class => $opt{class});
        }

        if (exists $expr->{call}) {
            foreach my $call (@{$expr->{call}}) {

                my @arguments;
                my $method = $call->{name};

                if (exists $call->{arg}) {

                    foreach my $arg (@{$call->{arg}}) {
                        if (ref $arg eq 'HASH') {
                            push @arguments, execute(struct => $arg);
                        }
                        else {
                            push @arguments, $arg;
                        }
                    }

                    foreach my $obj (@arguments) {
                        if (ref $obj eq 'Sidef::Types::String::Double') {
                            interpolate(self => $obj, class => $opt{class});
                        }
                    }

                    if (ref $self eq 'Sidef::Variable::Variable' and $method ne '=') {
                        my $value = $self->get_value;
                        $variables{$opt{class}}{$self->get_name} = $value;
                        $self = $value;
                    }

                    my $value = $self->$method(@arguments);
                    if (ref $self eq 'Sidef::Variable::Variable') {
                        $variables{$opt{class}}{$self->get_name} = $value;
                    }
                    $self = $value;

                }
                else {

                    if (ref $self eq 'Sidef::Variable::Variable') {
                        my $value = $self->get_value;
                        $variables{$opt{class}}{$self->get_name} = $value;
                        $self = $value;
                    }

                    $self = $self->$method;
                }
            }
        }

        return $self;
    }
    else {
        die "Struct error!\n";
    }
}

sub execute {
    my (%opt) = @_;

    my $struct = $opt{'struct'};

    my @results;
    foreach my $key (keys %{$struct}) {
        foreach my $expr (@{$struct->{$key}}) {
            push @results, execute_expr(class => $key, expr => $expr);
        }
    }

    return @results;
}

execute(struct => $struct);
