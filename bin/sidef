#!/usr/bin/perl

use 5.014;
use strict;
use warnings;

BEGIN { unshift(@INC, '../lib') }

binmode(STDOUT, ':encoding(UTF-8)');
binmode(STDERR, ':encoding(UTF-8)') if $^P == 0;
binmode(STDIN,  ':encoding(UTF-8)');

require Sidef::Init;

my $name    = 'Sidef';
my $version = $Sidef::VERSION;

my %args;
if (@ARGV and chr ord $ARGV[0] eq '-') {
    require Getopt::Std;
    Getopt::Std::getopts('E:d:Dho:ivHN:Wwc', \%args);
}

my %keywords = (
                if   => 'Sidef::Types::Bool::If',
                '\\' => 'Sidef::Variable::Ref',
                '*'  => 'Sidef::Variable::Ref',
               );

sub help_interactive {
    require Term::ReadLine;
    my $term = Term::ReadLine->new("$name $version -- help interactive mode");

    print <<"HELP";
Welcome to $name $version!  This is the interactive help utility.

Enter the name of any object, keyword, or topic to get help on writing
$name programs and using $name modules.  To quit this help utility, just
type "quit".

To get a list of available objects, or keywords, type "objects" or "keywords".

HELP

    {
        my $line = $term->readline('help> ') // do { print "\n"; return };

        my $parser = Sidef::Parser->new(script_name => '-H');
        my $struct = eval { $parser->parse_script(code => $line) };

        if ($@) {
            warn $@;
            redo;
        }

        my @refs = exists($keywords{$line}) ? $keywords{$line} : (map { ref($_) } execute_struct($struct));

        foreach my $ref (@refs) {
            $ref eq '' && do { warn "Not an object!\n"; next };
            system "man", $ref;
        }

        redo;
    }

}

if ($args{h}) {

    my %switches = (
                    '-i'             => 'interactive mode',
                    '-c'             => 'compile the code as a stand-alone perl program',
                    '-d dumped_file' => 'execute a dumped file',
                    '-D'             => 'dump the data structure of a program',
                    '-o output_file' => 'dump the data structure into a file (with -D)',
                    '-E program'     => 'one line of program',
                    '-H'             => 'interactive help',
                    '-N type'        => ["use a specific implementation for numbers", "valid types: fast, big, int, rat"],
                    '-v'             => 'print version',
                    '-w'             => 'enable warnings with stack backtrace',
                    '-W'             => 'make warnings fatal (with stack backtrace)',
                   );

    print <<"USAGE";

Usage: sidef [switches] [--] [programfile] [arguments]

USAGE

    require List::Util;
    my $max_width = List::Util::max(map { length } keys %switches);
    $max_width += 4;

    foreach my $key (sort { lc($a) cmp lc($b) or $b cmp $a } keys %switches) {
        if (ref $switches{$key} eq 'ARRAY') {
            printf "  %-${max_width}s%s\n", $key, $switches{$key}[0];
            foreach my $i (1 .. $#{$switches{$key}}) {
                printf "  %-${max_width}s%s\n", '', $switches{$key}[$i];
            }
        }
        else {
            printf "  %-${max_width}s%s\n", $key, $switches{$key};
        }
    }

    print <<"END";

Run '$0 -H' for more help with $name.

END

    exit 0;
}

if ($args{w}) {
    $SIG{__WARN__} = sub {
        require Carp;
        Carp::cluck(@_);
    };
}
elsif ($args{W}) {
    $SIG{__WARN__} = sub {
        require Carp;
        Carp::confess(@_);
    };
}

if (defined(my $type = $args{N})) {
    if ($type eq 'fast' or $type eq 'perl') {
        require Sidef::Types::Number::NumberFast;
    }
    elsif ($type eq 'rat') {
        require Sidef::Types::Number::NumberRat;
    }
    elsif ($type eq 'int') {
        require Sidef::Types::Number::NumberInt;
    }
    elsif ($type eq 'big' or $type eq 'float') {
        ## default
    }
    else {
        warn "Invalid type '${type}' for number implementation";
    }
}

if (defined $args{d}) {
    my $struct = do($args{d})
      || die "Can't load the data structure from file '$args{d}': $!\n";
    execute_struct($struct);
}
elsif (defined $args{H}) {
    help_interactive();
}
elsif (defined $args{v}) {
    print "$name $version\n";
    exit;
}
else {
    if (defined $args{i}) {
        require Term::ReadLine;
        my $term = Term::ReadLine->new("$name $version -- interactive mode");

        print qq{$name $version on $^O\n};
        print qq{Type "help", "copyright", "credits" or "license" for more information.\n};

        {
            my $line = $term->readline('>>> ') // do { print "\n"; exit };

            if ($line eq 'help') {
                help_interactive();
            }

            my $parser = Sidef::Parser->new(script_name => '-i');
            my $struct = eval { $parser->parse_script(code => $line) };

            if ($@) {
                warn $@;
                redo;
            }

            say for execute_struct($struct);
            redo;
        }

    }
    else {
        my $script_name = '-';

        my $code =
          exists $args{E}
          ? do { $script_name = '-E'; require Encode; Encode::decode_utf8($args{E}) }
          : (defined($ARGV[0]) && -f $ARGV[0]) ? do {

            my $file = shift;
            $script_name = $file;

            open my $fh, '<:encoding(UTF-8)', $file
              or die qq{Can't open sidef script "$file": $!\n};

            local $/;
            <$fh>;
          }
          : do { local $/; <> };

        $code // exit 2;
        my $parser = Sidef::Parser->new(script_name => $script_name);
        my $struct = $parser->parse_script(code => $code);

        if ($args{D}) {
            eval 'use Data::Dump';

            if ($@) {
                die "Data::Dump module is not installed!\n";
            }
            else {
                my $out_fh = \*STDOUT;

                if (defined $args{o}) {
                    open $out_fh, '>:encoding(UTF-8)', $args{o}
                      or die "Can't open file '$args{o}' for write: $!\n";
                }

                print {$out_fh} Data::Dump::pp($struct);
            }
        }
        elsif ($args{c}) {
            eval 'use Data::Dump';

            if ($@) {
                die "Data::Dump module is not installed!\n";
            }
            else {
                require File::Basename;
                my $path = File::Basename::dirname($INC{'Sidef.pm'});

                my $package_content = <<"HEAD";
#!$^X

eval 'exec $^X  -S \$0 \${1+"\$@"}'
    if 0; # not running under some shell

use utf8;
use 5.014;
use warnings;

use File::Temp qw(tempdir);
use File::Path qw(make_path);
use File::Spec::Functions qw(catdir catfile);

my \$DIR;
use lib \$DIR = tempdir(CLEANUP => 1);

binmode(STDOUT, ':encoding(UTF-8)');
binmode(STDERR, ':encoding(UTF-8)') if \$^P == 0;
binmode(STDIN,  ':encoding(UTF-8)');

foreach my \$mod (
HEAD

                require File::Find;
                File::Find::find(
                    {
                     no_chdir => 1,
                     wanted   => sub {
                         if (-f and /\.pm\z/) {

                             return if m{\bSidef\W+Init\b};

                             local $/;
                             open my $fh, '<:encoding(UTF-8)', $_
                               or die "Can't open file `$_' for reading: $!";

                             my $token = tr/A-Za-z0-9/_/cr;

                             $package_content .= qq{<<'${token}',\n};
                             $package_content .= <$fh>;
                             $package_content .= "\n$token\n";

                             close $fh;
                         }
                       }
                    } => $path
                );

                $package_content .= <<"FOOT";
) {
    if (\$mod =~ /^(?>##\\h*)?package\\h+([\\w::]+)/) {
        my \@parts = split(/::/, \$1);

        my \$name = pop \@parts;
        my \$dir = catdir(\$DIR, \@parts);

        if (\$#parts != -1 and not -d \$dir) {
            make_path(\$dir)
                or die qq{ERROR: Can't create dir \$dir: \$!};
        }

        my \$filename = catfile(\$dir, \$name . '.pm');

        open my \$fh, '>:encoding(UTF-8)', \$filename
            or die qq{ERROR: Can't create "\$filename": \$!};

        print {\$fh} \$mod;

        close \$fh
            or die qq{ERROR: Can't close "\$filename": \$!};
    }
    else {
        die qq{ERROR: can't get the package name!\n};
    }
}

FOOT

                if (exists $INC{'Sidef/Init.pm'}) {
                    my $filename = $INC{'Sidef/Init.pm'};

                    local $/;
                    open my $fh, '<:encoding(UTF-8)', $filename
                      or die "Can't open file `$filename' for reading: $!";

                    $package_content .= <$fh>;
                    $package_content .= "require Sidef;\n\n";

                    if (defined(my $type = $args{N})) {
                        if ($type eq 'fast' or $type eq 'perl') {
                            $package_content .= "require Sidef::Types::Number::NumberFast;\n";
                        }
                        elsif ($type eq 'rat') {
                            $package_content .= "require Sidef::Types::Number::NumberRat;\n";
                        }
                        elsif ($type eq 'int') {
                            $package_content .= "require Sidef::Types::Number::NumberInt;\n";
                        }
                    }

                    close $fh;
                }
                else {
                    die "ERROR: Can't find the `Sidef::Init' module!\n";
                }

                my $out_fh = \*STDOUT;

                if (defined $args{o}) {
                    open $out_fh, '>:encoding(UTF-8)', $args{o}
                      or die "Can't open file '$args{o}' for write: $!\n";
                }

                print {$out_fh} $package_content;

                print {$out_fh} "my \$struct = ";
                print {$out_fh} Data::Dump::pp($struct);
                print {$out_fh} ";\n";

                print {$out_fh} <<"EXEC";

#
## Execute the data structure
#

my \$exec = Sidef::Exec->new();
\$exec->execute(\$struct);
EXEC
            }
        }
        else {
            execute_struct($struct);
        }
    }
}

sub execute_struct {
    my ($struct) = @_;
    my $exec = Sidef::Exec->new();
    $exec->execute($struct);
}
